#include <mpi.h>
#include <iostream>
#include <vector>
#include <algorithm>
#include <cstdlib>
#include <ctime>

using namespace std;

/// Функція злиття двох відсортованих підмасивів у один загальний
void merge(vector<int>& arr, vector<int>& left, vector<int>& right) {
    arr.clear();
    int i = 0, j = 0;
    // Порівнюємо елементи з обох підмасивів і додаємо у результат
    while (i < left.size() && j < right.size()) {
        if (left[i] < right[j]) arr.push_back(left[i++]);
        else arr.push_back(right[j++]);
    }
    // Додаємо залишки з лівого або правого масиву
    while (i < left.size()) arr.push_back(left[i++]);
    while (j < right.size()) arr.push_back(right[j++]);
}

/// Рекурсивна функція сортування методом Merge Sort
void mergeSort(vector<int>& arr) {
    if (arr.size() <= 1) return;
    int mid = arr.size() / 2;
    vector<int> left(arr.begin(), arr.begin() + mid);
    vector<int> right(arr.begin() + mid, arr.end());
    mergeSort(left);
    mergeSort(right);
    merge(arr, left, right);
}

int main(int argc, char** argv) {
    MPI_Init(&argc, &argv);

    int rank, size;
    MPI_Comm_rank(MPI_COMM_WORLD, &rank); 
    MPI_Comm_size(MPI_COMM_WORLD, &size); 

    const int totalSize = 1000000;         
    vector<int> fullData;

    // Генерація повного масиву даних
    if (rank == 0) {
        srand(time(0));
        fullData.resize(totalSize);
        for (int i = 0; i < totalSize; ++i)
            fullData[i] = rand() % 100000;
    }

    // Кожен процес отримує однакову кількість елементів
    int localSize = totalSize / size;
    vector<int> localData(localSize);

    // Розсилка частин масиву всім процесам
    MPI_Scatter(fullData.data(), localSize, MPI_INT,
        localData.data(), localSize, MPI_INT,
        0, MPI_COMM_WORLD);

    // З моменту початку сортування до завершення злиття
    double startTime = MPI_Wtime();

    // Локальне сортування (кожен процес сортує свою частину)
    mergeSort(localData);

    // Паралельне злиття
    int step = 1;
    while (step < size) {
        if (rank % (2 * step) == 0) {
            if (rank + step < size) {
                int incomingSize;
                MPI_Recv(&incomingSize, 1, MPI_INT, rank + step, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
                vector<int> incoming(incomingSize);
                MPI_Recv(incoming.data(), incomingSize, MPI_INT, rank + step, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
                merge(localData, localData, incoming);  // Злиття отриманих даних
            }
        }
        else {
            // Відправляємо свою частину процесу з меншим рангом
            int dest = rank - step;
            int s = localData.size();
            MPI_Send(&s, 1, MPI_INT, dest, 0, MPI_COMM_WORLD);
            MPI_Send(localData.data(), s, MPI_INT, dest, 0, MPI_COMM_WORLD);
            break; 
        }
        step *= 2;
    }

    double endTime = MPI_Wtime();
    double localTotalTime = endTime - startTime;

    // Збір часу виконання
    double* allTimes = nullptr;
    if (rank == 0)
        allTimes = new double[size];

    MPI_Gather(&localTotalTime, 1, MPI_DOUBLE,
        allTimes, 1, MPI_DOUBLE,
        0, MPI_COMM_WORLD);

    // Вивід статистики
    if (rank == 0) {
        double globalMax = *max_element(allTimes, allTimes + size);

        cout << "Total elements sorted: " << totalSize << endl;
        cout << "Number of processes: " << size << endl;
        cout << "Total elapsed time: " << globalMax << " seconds" << endl;

        for (int i = 0; i < size; ++i)
            cout << "Process " << i << " execution time: " << allTimes[i] << " seconds" << endl;

        delete[] allTimes;
    }

    MPI_Finalize();
    return 0;
}
